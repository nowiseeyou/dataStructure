## 十大经典排序算法 ##

排序算法是《数据结构与算法》 中最基本的算法之一。

排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。

#### 关于时间复杂度 ####

平方阶（O(n2)）排序各类简单排序：直接插入，直接选择和冒泡排序；

线性对数阶（O(nlog2n)） 排序 快速排序、堆排序和归并排序；

O(n1+§)) 排序，§是介于0和1之间的常熟。希尔排序；

线性阶（O(n)）排序 基数排序，此外还有桶、箱排序。

#### 关于稳定 ####

稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。

不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。

#### 名词解释 ####

- n：数据模型
- k："桶"的个数
- In-place：占用常数内存，不占用额外内存
- Out-place：占用额外内存
- 稳定性：排序后2个相等键值的顺序和排序之前她们的顺序相同。


----------------------------------------------------------------------

## 冒泡排序 ##
冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复的走访过要排序的数列，一次比较两个元素，如果她们的顺序错误就把她们交换过来。走访数列的工作是 重复的进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢'浮'到数列的顶端。

作为简单的排序算法之一，冒泡排序就像是 Abandon 在单词书里出现的感觉一样，每次都在第一页第一个位，所以最熟悉。冒泡排序有一种优化算法，就是立一个 flag ，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大的作用。

### 算法步骤 ###

- 比较相邻的元素，如果第一个比第二个大，就交换他们的两个的位置。
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
- 针对所有的元素重复以上的步骤，除了最后一个。
- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

### golang ###

    func bubbleSort(arr []int) []int {
		length := len(arr)
		for i := 0; i< length; i++ {
			for j := 0; j< length-1-i; j++ {
				if arr[j] > arr[j+1] {
					arr[j] , arr[j+1] = arr[j+1] , arr[j]
				}
			}
		}
		return arr
	}

### PHP ###

	function bubbleSort($arr){
		$len = count($arr);
		for($i=0;$i<$len-1;$i++){
			for($j=0;$j<$len -$i-1;$j++){
				if($arr[$j] > $arr[$j+1]){
					$temp = $arr[$j];
					$arr[$j] = $arr[$j+1];
					$arr[$j+1] = $temp;
				}
			}
		}
		return $arr;
	}



## 选择排序 ##

选择排序是一种简单直观的排序算法，无论什么数据进去都是  O(n²)  的时间复杂度。所以
用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。

### 算法步骤 ###

- 首先在未排序的序列中找到最小（大）元素，存放到排序序列的起始位置。
- 再冲神域未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
- 重复第二步。

### golang ###

	func selectionSort(arr []int) []int{
		length := len(arr)
		for i := 0; i< length -1; i++ {
			min ：= i
			for j := i+1; j <length; j++ {
				if arr[min] > arr[j]{
					min = j
				}
			}
			arr[i],arr[min] = arr[min],arr[i]
		}
		return  arr
	}

### PHP ###

	function selectionSort($arr){
		$len = count($arr);
		for($ =0;$i<$len-1;$i++){
			$minIndex = $i;
			for($j = $i+1;$j< $len;$j++){
				if($arr[$j] < $arr[$minIndex]){
					$minIndex = $j;
				}
			}
			$temp = $arr[$i];
			$arr[$i] = $arr[$minIndex];
			$arr[$minIndex] = $temp;
		}
	}