## 十大经典排序算法 ##

排序算法是《数据结构与算法》 中最基本的算法之一。

排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。

#### 关于时间复杂度 ####

平方阶（O(n2)）排序各类简单排序：直接插入，直接选择和冒泡排序；

线性对数阶（O(nlog2n)） 排序 快速排序、堆排序和归并排序；

O(n1+§)) 排序，§是介于0和1之间的常熟。希尔排序；

线性阶（O(n)）排序 基数排序，此外还有桶、箱排序。

#### 关于稳定 ####

稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。

不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。

#### 名词解释 ####

- n：数据模型
- k："桶"的个数
- In-place：占用常数内存，不占用额外内存
- Out-place：占用额外内存
- 稳定性：排序后2个相等键值的顺序和排序之前她们的顺序相同。


----------------------------------------------------------------------

## 冒泡排序 ##
冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复的走访过要排序的数列，一次比较两个元素，如果她们的顺序错误就把她们交换过来。走访数列的工作是 重复的进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢'浮'到数列的顶端。

作为简单的排序算法之一，冒泡排序就像是 Abandon 在单词书里出现的感觉一样，每次都在第一页第一个位，所以最熟悉。冒泡排序有一种优化算法，就是立一个 flag ，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大的作用。

### 算法步骤 ###

- 比较相邻的元素，如果第一个比第二个大，就交换他们的两个的位置。
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
- 针对所有的元素重复以上的步骤，除了最后一个。
- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

### golang ###

    func bubbleSort(arr []int) []int {
		length := len(arr)
		for i := 0; i< length; i++ {
			for j := 0; j< length-1-i; j++ {
				if arr[j] > arr[j+1] {
					arr[j] , arr[j+1] = arr[j+1] , arr[j]
				}
			}
		}
		return arr
	}

### PHP ###

	function bubbleSort($arr){
		$len = count($arr);
		for($i=0;$i<$len-1;$i++){
			for($j=0;$j<$len -$i-1;$j++){
				if($arr[$j] > $arr[$j+1]){
					$temp = $arr[$j];
					$arr[$j] = $arr[$j+1];
					$arr[$j+1] = $temp;
				}
			}
		}
		return $arr;
	}


----------


## 选择排序 ##

选择排序是一种简单直观的排序算法，无论什么数据进去都是  O(n²)  的时间复杂度。所以
用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。

### 算法步骤 ###

- 首先在未排序的序列中找到最小（大）元素，存放到排序序列的起始位置。
- 再冲神域未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
- 重复第二步。

### golang ###

	func selectionSort(arr []int) []int{
		length := len(arr)
		for i := 0; i< length -1; i++ {
			min ：= i
			for j := i+1; j <length; j++ {
				if arr[min] > arr[j]{
					min = j
				}
			}
			arr[i],arr[min] = arr[min],arr[i]
		}
		return  arr
	}

### PHP ###

	function selectionSort($arr){
		$len = count($arr);
		for($ =0;$i<$len-1;$i++){
			$minIndex = $i;
			for($j = $i+1;$j< $len;$j++){
				if($arr[$j] < $arr[$minIndex]){
					$minIndex = $j;
				}
			}
			$temp = $arr[$i];
			$arr[$i] = $arr[$minIndex];
			$arr[$minIndex] = $temp;
		}
	}



----------


## 插入排序 ##

插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，单他的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，她的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。

### 算法步骤 ###

- 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
- 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后边）

### golang ###

    func insertionSort(arr []int) []int() {
		for i := range arr {
			preIndex :=  i - 1
			current := arr[i]
			for preIndex >= 0 && arr[preIndex] > current {
				arr[preIndex + 1] = arr[preIndex]
				preIndex -= 1
			}
			arr[preIndex+1] = current
		}
		return arr
	}

### PHP ###

    function insertionSort($arr) {
		$len = count($arr);
		for ($i =1; $i < $len; $i++) {
			$preIndex = $i -1;
			$current = $arr[$i];
			while($preIndex >= 0 && $arr[$preIndex] > $current) {
				$arr[$preIndex + 1] = $arr[$preIndex];
				$preIndex--;
			}
			$arr[$preIndex + 1] = $current;
		}
		return $arr;
	}



----------

## 希尔排序 ##

希尔排序，也称地减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出的改进方法：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到**线性排序**的效率；
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。

希尔排序的基本思路是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序时”，再对全体记录进行一次直接插入排序。

### 算法步骤 ###

- 选择一个增量序列 t1,t2,...,tk,其中 ti > tj,tk =1;
- 按增量序列个数K，对序列进行K趟排序；
- 每趟排序，根据对应的增量 ti ，将待排序列分割成若干长度 为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

### golang ###

    func shellOrder(arr []int) []int {
		length := len(arr)
		gap := 1
		for gap < gap/3 {
			gap = gap*3 + 1
		}
		for gap > 0 {
			for i := gap; i < length; i++ {
				temp := arr[i]
				j := i -gap
				for j >= 0 && arr[j] >temp {
					arr[j+gap] = arr[j]
				}
				arr[j+gap] = temp
			}
			gap = gap/3
		}
		return arr
	}

### PHP ###

    function shellSort($arr) {
		$len = count($arr);
		$temp = 0;
		$gap = 1;
		while($gap < $len / 3){
			$gap = $gap * 3 + 1;
		}
		for ($gap;$gap>0;$gap = floor($gap/3)){
			for ($i = $gap;$i < $len;$i++){
				$temp = $arr[$i];
				for($j = $i - $gap;$j >= 0 && $arr[$j] > $temp; $j -= $gap){
					$arr[$j+$gap] = $arr[$j];
				}
				$arr[$j+$gap] = $temp;
			}
		}
		return $arr;
	}


----------

## 归并排序 ##

归并排序（Merge sort） 是建立在归并操作上的一种有效的排序算法。该算法采用分治法（Divide and Conquer）的一个非常典型的应用。

作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：

- 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第二种方法）；
- 自下而上的迭代

和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O（nlogn）的时间复杂度。代价是需要额外的内存空间。

### 算法步骤 ###

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
3. 比较两个指针所指向的元素，选择相对小的元素放入合并空间，并移动指针到下一位置；
4. 重复步骤3 知道某一指针达到序列尾；
5. 将宁一个序列剩下的所有元素直接复制到合并序列尾。

### golang ###

	func mergeSort(arr []int) []int {
		length := len(arr)
		if length < 2 {
			return arr
		}

		middle := lenth/2
		left := arr[0:middle]
		right := arr[middle:]
		return merge(mergeSort(left), mergeSort(right))
	}

	func merge(left []int, right []int) []int {
		var result []int
		for len(left) != 0 && len(right) != 0 {
			if left[0] <= right[0] {
				result = append(result, left[0])
				left = left[1:]
			} else {
				result = append(result, right[0])
				right = right[1:]
			}
		}

		for len(left) != 0 {
			result = append(result, left[0])
			left = left[1:]
		}

		for len(right) != 0 {
			result = append(result, right[0])
			right = right[1:]
		}

		return result
	}


### PHP ###

    function mergeSort($arr) {
		$len = count($arr)
		if($len < 2) {
			return $arr;
		}
		$middle = floor($len / 2);
		$left = array_slice($arr,0,$middle);
		$right = array_slice($arr,$middle);

		return merge(mergeSort($left),mergeSort($right));
	}

	function merge($left,$right) {
		$result = [];

		while (count($left) > 0 && count($right) > 0) {
			if($lefht[0] <= $right[0]){
				$result[] = array_shift($left);
			}else{
				$result[] = array_shift($right);
			}
		}

		while (count($left)) {
			$result[] = array_shift($left);
		}

		while (count($right)) {
			$result[] = array_shift($right);
		}

		return $result;
	}


## 快速排序 ##

快速排序是由东尼.霍尔所发现的一种排序算法，在平均情况下，排序n个项目要 O（nlogn）次比较。在最坏状况下则需要 O(N^2) 次比较，但这种情况并不常见。事实上，快速排序通常明显比其他 O(nlogn)算法更快，因为它的内部循环（inner loop） 可以在大部分的架构上很有效率的被实现出来。

快速排序使用分治法（Divide and conquer）策略来把衣蛾串行（list）分为两个子串行（sub-lists）。

快速排序又是一种分而治之思想在排序算法的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。

快速排序的名字起的简单粗暴，因为一听这个名字就知道它存在的意义，就是快，而且效率高！他是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O（n^2）,但是人家就是优秀，在大多数情况下都比平均时间复杂度 为O(n logn)的排序算法表现更好，《算法艺术与信息学竞赛》答案就是：

    快速排序的最坏运行情况是O（n^2），比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn),且 O(n logn) 记号中隐含的常数因子很小，
	比复杂度稳定等于O(nlogn)的归并排序要小的多。所以，绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。

### 算法步骤 ###

1. 从数列中挑出一个元素，称为"基准"(pivot)；
2. 重新排序数列，所有的元素比基准值小的摆放在基准前面，所有的元素比基准值大的摆在基准值的后边（相同的数可以放在任意一边）。在这个分区退出后，该基准值就处于数列的中间位置。这个称为分区（partition）操作;
3. 递归地（recursive） 把小于基准元素的子数列和大于基准值元素的子序列排序。


### golang ###

	func quickSort(arr []int) []int {
		return _quickSort(arr, 0, len(arr)-1)
	}

	func _quickSort(arr []int, left,right int) []int {
		if left < right  {
			partitionIndex := partition(arr, left ,right)
			_quickSort(arr, left, partitionIndex-1)
			_quickSort(arr, partitionIndex+1,right)
		}
		return arr
	}

	func partition (arr []int, left, right int) int {
		pivot := left
		index := pivot + 1

		for i := index; i <= right; i++ {
			if arr[i] < arr[pivot] {
				swap(arr, i, index)
				index += 1
			}
		}

		swap(arr, pivot, index -1)
		reutnr index - 1
	}

	func swap (arr []int , i,j int) {
		arr[i], arr[j] = arr[j], arr[i]
	}


